<?xml version="1.0" encoding="UTF-8"?>  
<beans xmlns="http://www.springframework.org/schema/beans" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop"  
    xmlns:tx="http://www.springframework.org/schema/tx" xmlns:p="http://www.springframework.org/schema/p" xmlns:util="http://www.springframework.org/schema/util" xmlns:jdbc="http://www.springframework.org/schema/jdbc"  
    xmlns:cache="http://www.springframework.org/schema/cache"  
    xsi:schemaLocation="  
    http://www.springframework.org/schema/context  
    http://www.springframework.org/schema/context/spring-context.xsd  
    http://www.springframework.org/schema/beans  
    http://www.springframework.org/schema/beans/spring-beans.xsd  
    http://www.springframework.org/schema/tx  
    http://www.springframework.org/schema/tx/spring-tx.xsd  
    http://www.springframework.org/schema/jdbc  
    http://www.springframework.org/schema/jdbc/spring-jdbc-3.1.xsd  
    http://www.springframework.org/schema/cache  
    http://www.springframework.org/schema/cache/spring-cache-3.1.xsd  
    http://www.springframework.org/schema/aop  
    http://www.springframework.org/schema/aop/spring-aop.xsd  
    http://www.springframework.org/schema/util  
    http://www.springframework.org/schema/util/spring-util.xsd">

    <context:annotation-config/>

    <!-- =========================================================
         Shiro Core Components - Not Spring Specific
         ========================================================= -->
    <!-- Shiro's main business-tier object for web-enabled applications
         (use DefaultSecurityManager instead when there is no web environment)-->
    <bean id="securityManager" class="org.apache.shiro.web.mgt.DefaultWebSecurityManager">
        <property name="cacheManager" ref="cacheManager"/>
        <!-- Single realm app.  If you have multiple realms, use the 'realms' property instead. -->
        <property name="realm" ref="jdbcRealm"/>
    </bean>
    <!-- Let's use some enterprise caching support for better performance.  You can replace this with any enterprise
         caching framework implementation that you like (Terracotta+Ehcache, Coherence, GigaSpaces, etc -->
    <bean id="cacheManager" class="org.apache.shiro.cache.ehcache.EhCacheManager">
        <!-- Set a net.sf.ehcache.CacheManager instance here if you already have one.  If not, a new one
             will be creaed with a default config:
             <property name="cacheManager" ref="ehCacheManager"/> -->
        <!-- If you don't have a pre-built net.sf.ehcache.CacheManager instance to inject, but you want
             a specific Ehcache configuration to be used, specify that here.  If you don't, a default
             will be used.: -->
        <property name="cacheManagerConfigFile" value="classpath:ehcache.xml"/>
    </bean>

    <!-- Used by the SecurityManager to access security data (users, roles, etc).
         Many other realm implementations can be used too (PropertiesRealm,
         LdapRealm, etc. -->

    <bean id="jdbcRealm" class="com.roye.shrio.Realm.ShrioRealm"></bean>
    <!--
        4. lifecycleBeanPostProcessor  在spring IOC 容器中 自动的配置bean的生命周期方法
    -->
    <bean id="lifecycleBeanPostProcessor" class="org.apache.shiro.spring.LifecycleBeanPostProcessor"/>

    <!-- 5. Enable Shiro Annotations for Spring-configured beans.  Only run after
         the lifecycleBeanProcessor has run: -->
    <bean class="org.springframework.aop.framework.autoproxy.DefaultAdvisorAutoProxyCreator"
          depends-on="lifecycleBeanPostProcessor"/>
    <bean class="org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor">
        <property name="securityManager" ref="securityManager"/>
    </bean>



    <!-- 6. Define the Shiro Filter here (as a FactoryBean) instead of directly in web.xml -
        web.xml uses the DelegatingFilterProxy to access this bean.  This allows us
        to wire things with more control as well utilize nice Spring things such as
        PropertiesPlaceholderConfigurer and abstract beans or anything else we might need:

        这个id='shrioFilter' 必须和web.xml 中的 <filter-name>shiroFilter</filter-name> 是一致的

        -->
    <bean id="shiroFilter" class="org.apache.shiro.spring.web.ShiroFilterFactoryBean">
        <property name="securityManager" ref="securityManager"/>
        <property name="loginUrl" value="/jsp/login.jsp"/>
        <property name="successUrl" value="/index"/>
        <property name="unauthorizedUrl" value="/s/unauthorized"/>
        <!--
         配置哪些页面需要保护， 以及访问这些页面需要的权限
         1. anon：可以被匿名访问
         2. authc: 必须被认证后才能被访问。
        -->
        <property name="filterChainDefinitions">
            <value>
                /favicon.ico = anon
                /logo.png = anon
                /shiro.css = anon
                /jsp/login.jsp = anon
                /s/login = anon
                # allow WebStart to pull the jars for the swing app:
                /*.jar = anon
                # everything else requires authentication:
                /** = authc
            </value>
        </property>
    </bean>

    <!--  图形验证码的配置  -->
    <!-- 加载db.properties 中的内容 -->
   <!-- <context:property-placeholder location="classpath:db.properties" />-->
    
    <!--<context:component-scan base-package="mapper"></context:component-scan>-->
    
    
 <!-- 配置数据源  dbcp-->
 <!-- 
  数据库连接池的解决方案是在应用程序启动时建立足够的数据库连接，并讲这些连接组成一个连接池(简单说：
  在一个“池”里放了好多半成品的数据库联接对象)，由应用程序动态地对池中的连接进行申请、使用和释放。
  对于多于连接池中连接数的并发请求，应该在请求队列中排队等待。
  并且应用程序可以根据池中连接的使用率，动态增加或减少池中的连接数
  -->
<!-- <bean id="dataSource"  class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close">
    <property name="driverClassName" value="${jdbc.driver}" />  
    <property name="url" value="${jdbc.url}" />  
    <property name="username" value="${jdbc.username}" />     
    <property name="password" value="${jdbc.password}" />  
    &lt;!&ndash; 连接池的最大使用连接数 &ndash;&gt;
    <property name="maxActive" value="30" /> 
    &lt;!&ndash; 连接池的最小空闲 &ndash;&gt;
    <property name="maxIdle" value="5" />   
</bean> -->
<!-- sqlSessionFactory -->
<!--配置sqlSessionFactory-->  
    <!--<bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean">   -->
        <!--&lt;!&ndash; 数据库连接池 &ndash;&gt;-->
        <!--<property name="dataSource" ref="dataSource" /> -->
        <!--&lt;!&ndash; 加载mybatis的全局配置文件 &ndash;&gt;  -->
        <!--<property name="configLocation" value="classpath:mybatis/sqlMapConfig.xml"/>  -->
        <!--&lt;!&ndash;  <property name="mapperLocations" value="mapper/*.xml"/> &ndash;&gt;-->
    <!--</bean> -->
    <!---->
     <!--&lt;!&ndash; mapper扫描器 &ndash;&gt;-->
     <!--<bean class="org.mybatis.spring.mapper.MapperScannerConfigurer">-->
         <!--&lt;!&ndash; 如果需要扫描多个，中间使用半角的逗号 &ndash;&gt;-->
         <!--<property name="basePackage" value="mapper"></property>-->
          <!--&lt;!&ndash; 要用 sqlSessionFactoryBeanName &ndash;&gt;-->
         <!--<property name="sqlSessionFactoryBeanName" value="sqlSessionFactory" />-->
     <!--</bean>-->
    <!---->
     <!-- 
        事务管理器，对mybatis 操作数据库事务控制，
        spring 使用jdbc的事务控制类。
      -->
      <!-- 必须加上这句话 -->
<!--      <tx:annotation-driven transaction-manager="transactionManager" proxy-target-class="true"/>
      <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager" >
          <property name="dataSource" ref="dataSource" />
      </bean> -->
</beans>    